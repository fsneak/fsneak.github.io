{
  "name": "fsneak的博客-首页",
  "tagline": "",
  "body": "# 任务顺序执行机制\r\n\r\n## 使用队列顺序执行任务\r\n公司前人留下来了一个工具类`MultiThreadQueueWorker`。\r\n作用是作为一个任务执行器，保证放入执行器中的同类型任务都是顺序执行，并且不需要为每种类型的任务都生成一个线程去执行。\r\n该执行器的内部仍然是为每种类型的任务创建一个队列，每次新加的任务都会放入到队列中去。\r\n但是在创建队列的同时，该执行器还会将队列的key放入一个阻塞队列keyQueue中。\r\n各个线程去抢占keyQueue中的key，抢到key的线程才执行相应任务队列的第一个任务，执行完后再将key放回keyQueue中，等待下一次线程的抢占。\r\n大致代码如下：\r\n\r\n```\r\npublic void accept(String key, Task task) {\r\n    if(!taskQueueMap.containsKey(key)) {\r\n        Queue ret = taskQueueMap.putIfAbsent(key, new Queue());\r\n        if(ret == null) {\r\n            keyQueue.offer(key);\r\n        }\r\n    }\r\n    \r\n    Queue queue = taskQueue.get(key);\r\n    queue.add(task);\r\n}\r\n\r\npublic void process() {\r\n    // invoked by every worker thread\r\n    while(running) {\r\n        String key = keyQueue.take();\r\n        Queue queue = taskQueue.get(key);\r\n        Task task = queue.poll();\r\n        task.execute();\r\n        keyQueue.offer(key);\r\n    }\r\n}\r\n```\r\n\r\n而实际代码当然更为复杂，还需要处理各种同步的情况，队列为空的时候要把key从keyQueue中移除，有任务了再把它加回去等等。\r\n这导致这个类的代码维护比较困难，事实上也出现了由于任务执行报错导致key没有放回keyQueue，致使该key对应的任务队列永远不会再被执行的bug。\r\n\r\n此外，由于这个类缺乏对于空队列的回收机制，如果对于每种类型都创建一个队列，则队列数量可能会有上万或者十几万个，而其中有可能大部分都是空的。\r\n所以实际运用时往往会控制队列的数量，使用某种方式将多个key映射到同一个队列上（哈希）。\r\n这就额外增加了任务执行顺序的条件。\r\n比如如果类型A和B都映射到队列1上，而某个A任务执行时间较长（比如IO操作、网络拥塞等），排在该任务后面的B任务都会受到影响无法立即执行。\r\n哪怕A任务和B任务之间没有业务逻辑上的关系。\r\n\r\n基于上述原因，我比较想用一些已有的稳定的机制替换`MultiThreadQueueWorker`。\r\n但是在我的印象中，想到的要么是为一个每一个队列安排一个线程（那样要么会生成大量线程，要么要将不同类型的任务安排在同一个队列中），要么就是变成上述的类似机制。\r\n\r\n最后，果然还是**万能的StackOverflow**救了我。\r\n\r\n## 使用Future保证任务的顺序执行\r\nStackOverflow的地址[在此](http://stackoverflow.com/questions/29889885/java-divide-incoming-work-uniformly-via-hashing-in-multithreaded-evnironments/29893297#29893297)。\r\n\r\n文章提供了两种解决方案。\r\n\r\n* 基于Java8\r\n\r\n```\r\nConcurrentMap<String, CompletableFuture<Void>> dispatchQueues = ...\r\n\r\npublic CompletableFuture<Void> dispatch(String queueName, Runnable task) {\r\n  return dispatchQueues.compute(queueName, (k, queue) -> {\r\n    return (queue == null)\r\n        ? CompletableFuture.runAsync(task)\r\n        : queue.thenRunAsync(task);\r\n  });\r\n}\r\n```\r\n\r\n* 基于Guava\r\n\r\n```\r\nListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());\r\nStriped<Lock> locks = Striped.lock(256);\r\nConcurrentMap<String, ListenableFuture<?>> dispatchQueues = new ConcurrentHashMap<String, ListenableFuture<?>>();\r\n\r\npublic ListenableFuture<?> dispatch(String queueName, final Runnable task) {\r\n    Lock lock = locks.get(queueName);\r\n    lock.lock();\r\n    try {\r\n        ListenableFuture<?> future = dispatchQueues.get(queueName);\r\n        if (future == null) {\r\n            future = executor.submit(task);\r\n        } else {\r\n            final SettableFuture<Void> next = SettableFuture.create();\r\n            future.addListener(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        task.run();\r\n                    } finally {\r\n                        next.set(null);\r\n                    }\r\n                }\r\n            }, executor);\r\n\r\n            future = next;\r\n        }\r\n        dispatchQueues.put(queueName, future);\r\n        return future;\r\n    }\r\n    finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n代码不同但是原理是类似的，即Future运行完成后的回调机制。\r\n首先创建一个Map用于存放任务类型和对应Future。\r\n提交任务时，如果Map中没有该任务对应的Future，则将任务提交给线程池后把返回的Future放入Map中。\r\n当有对应的Future时，则将要执行的任务注册到Future的回调中，并且使用注册后返回的Future替换Map中已有的Future。\r\n这样，实际上形成了一个**任务链表**，而Map中存储的总是该类型的最后一个任务。\r\n这样既保证了任务的先后执行顺序，也没有将任务类型和线程绑定，各个类型任务之间相互独立。\r\n又由于没有用显示的容器去存储任务，任务执行完后也就不会有其他的空间开销。\r\n可以说从各个方面都解决了上述使用显示的队列去保证任务顺序执行时带来的难题！\r\n\r\n有感而发，故写下了这篇文章。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}